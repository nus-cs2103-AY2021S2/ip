package blarb;

import java.io.IOException;
import java.time.format.DateTimeParseException;
import java.util.InputMismatchException;

/**
 * {@code Processor} decides on the course of action for Blarb.
 */
class Processor {
    /**
     * Checks if Blarb will terminate.
     *
     * @param input User input
     * @return Termination status.
     */
    public boolean willTerminate(String input) {
        CommandLine cml = Parser.parse(input);
        return cml.command.equals(Command.BYE) && cml.isSingleCommand();
    }

    /**
     * Executes Blarb's will.
     *
     * @param input User input
     * @return Blarb's response output.
     */
    public Output execute(String input, Tasklist tasklist, Storage storage) {
        CommandLine cml = Parser.parse(input);
        switch (cml.command) {
        case DONE:
            return executeDone(cml, tasklist, storage);
        case DELETE:
            return executeDelete(cml, tasklist, storage);
        case TODO:
            return executeToDo(cml, tasklist, storage);
        case DEADLINE:
            return executeDeadline(cml, tasklist, storage);
        case EVENT:
            return executeEvent(cml, tasklist, storage);
        case EDIT:
            return executeEdit(cml, tasklist, storage);
        case FIND:
            return executeFind(cml, tasklist);
        case LIST:
            return executeList(cml, tasklist);
        case BYE:
            return executeBye(cml);
        case UNKNOWN:
            return executeUnknown(input);
        default:
            assert false;
        }
        return executeUnknown(input);
    }

    /**
     * Executes the done command.
     *
     * @param cml      Input commandline
     * @param tasklist Tasklist of tasks
     * @param storage  Storage processing unit
     * @return Output generated by the done command
     */
    private Output executeDone(CommandLine cml, Tasklist tasklist, Storage storage) {
        String normal = null;
        String warn = null;
        boolean isNotice = true;
        try {
            int index = Integer.parseInt(cml.description) - 1;
            normal = tasklist.done(index);
            isNotice = false;
            storage.refile(tasklist);
        } catch (IOException ex) {
            warn = "Cannot access storage.";
        } catch (ArrayIndexOutOfBoundsException ex) {
            normal = "What have you done! More specific!";
        } catch (IndexOutOfBoundsException ex) {
            normal = "There is no such task.";
        } catch (NumberFormatException ex) {
            normal = "Done what now? I don't understand";
        }
        assert normal != null;
        return new Output(isNotice, normal, warn);
    }

    /**
     * Executes the delete command.
     *
     * @param cml      Input commandline
     * @param tasklist Tasklist of tasks
     * @param storage  Storage processing unit
     * @return Output generated by the delete command
     */
    private Output executeDelete(CommandLine cml, Tasklist tasklist, Storage storage) {
        String normal = null;
        String warn = null;
        boolean isNotice = true;
        try {
            int index = Integer.parseInt(cml.description) - 1;
            normal = tasklist.delete(index);
            isNotice = false;
            storage.refile(tasklist);
        } catch (IOException ex) {
            warn = "Cannot access storage.";
        } catch (ArrayIndexOutOfBoundsException ex) {
            normal = "What do you want to hide?";
        } catch (IndexOutOfBoundsException ex) {
            normal = "There is no such task.";
        } catch (NumberFormatException ex) {
            normal = "You can't delete your past.";
        }
        assert normal != null;
        return new Output(isNotice, normal, warn);
    }

    /**
     * Executes the todo command.
     *
     * @param cml      Input commandline
     * @param tasklist Tasklist of tasks
     * @param storage  Storage processing unit
     * @return Output generated by the todo command
     */
    private Output executeToDo(CommandLine cml, Tasklist tasklist, Storage storage) {
        String normal = null;
        String warn = null;
        boolean isNotice = true;
        try {
            if (cml.isSingleCommand()) {
                throw new InputMismatchException();
            }
            Task task = new ToDo(cml.description);
            normal = tasklist.add(task);
            isNotice = false;
            storage.file(task);
        } catch (IOException ex) {
            warn = "Cannot access storage.";
        } catch (InputMismatchException ex) {
            normal = "Todo what?";
        }
        assert normal != null;
        return new Output(isNotice, normal, warn);
    }

    /**
     * Executes the deadline command.
     *
     * @param cml      Input commandline
     * @param tasklist Tasklist of tasks
     * @param storage  Storage processing unit
     * @return Output generated by the deadline command
     */
    private Output executeDeadline(CommandLine cml, Tasklist tasklist, Storage storage) {
        String normal = null;
        String warn = null;
        boolean isNotice = true;
        try {
            if (cml.isSingleCommand()) {
                throw new InputMismatchException();
            }
            String[] fragments = cml.description.split(" /by ");
            Task task = new Deadline(fragments[0], fragments[1]);
            normal = tasklist.add(task);
            isNotice = false;
            storage.file(task);
        } catch (IOException ex) {
            warn = "Cannot access storage.";
        } catch (ArrayIndexOutOfBoundsException ex) {
            normal = "Type the deadline, then give the time using \"/by\".";
        } catch (DateTimeParseException ex) {
            normal = "Deadline time must be in the format of yyyy-mm-dd.";
        } catch (InputMismatchException ex) {
            normal = "Someone's having trouble with deadlines.";
        }
        assert normal != null;
        return new Output(isNotice, normal, warn);
    }

    /**
     * Executes the event command.
     *
     * @param cml      Input commandline
     * @param tasklist Tasklist of tasks
     * @param storage  Storage processing unit
     * @return Output generated by the event command
     */
    private Output executeEvent(CommandLine cml, Tasklist tasklist, Storage storage) {
        String normal = null;
        String warn = null;
        boolean isNotice = true;
        try {
            if (cml.isSingleCommand()) {
                throw new InputMismatchException();
            }
            String[] fragments = cml.description.split(" /at ");
            Task task = new Event(fragments[0], fragments[1]);
            normal = tasklist.add(task);
            isNotice = false;
            storage.file(task);
        } catch (IOException ex) {
            warn = "Cannot access storage.";
        } catch (ArrayIndexOutOfBoundsException ex) {
            normal = "Type the event, then give the time using \"/at\".";
        } catch (InputMismatchException ex) {
            normal = "Tell me the event!";
        }
        assert normal != null;
        return new Output(isNotice, normal, warn);
    }

    /**
     * Executes the find command.
     *
     * @param cml      Input commandline
     * @param tasklist Tasklist of tasks
     * @return Output generated by the find command
     */
    private Output executeFind(CommandLine cml, Tasklist tasklist) {
        String normal;
        boolean isNotice = true;
        try {
            if (cml.isSingleCommand()) {
                throw new InputMismatchException();
            }
            normal = tasklist.find(cml.description);
            isNotice = false;
        } catch (InputMismatchException ex) {
            normal = "I need a clue to find stuff!";
        }
        assert normal != null;
        return new Output(isNotice, normal);
    }

    /**
     * Executes the list command.
     *
     * @param cml      Input commandline
     * @param tasklist Tasklist of tasks
     * @return Output generated by the list command
     */
    private Output executeList(CommandLine cml, Tasklist tasklist) {
        String normal = cml.isSingleCommand()
                ? tasklist.list()
                : "Listing is simple, so typing \"list\" would suffice.";
        return new Output(false, normal);
    }

    /**
     * Executes the bye command.
     *
     * @param cml Input commandline
     * @return Output generated by the bye command
     */
    private Output executeBye(CommandLine cml) {
        String normal = cml.isSingleCommand()
                ? "Hasta la vista, baby."
                : "Type \"bye\" to see me go.";
        return new Output(false, normal);
    }

    /**
     * Executes the edit command.
     *
     * @param cml      Input commandline
     * @param tasklist Tasklist of tasks
     * @param storage  Storage processing unit
     * @return Output generated by the edit command
     */
    private Output executeEdit(CommandLine cml, Tasklist tasklist, Storage storage) {
        String normal = null;
        String warn = null;
        boolean isNotice = true;
        try {
            if (cml.isSingleCommand()) {
                throw new InputMismatchException();
            }
            String[] fragments = cml.description.split(" ", 2);
            normal = tasklist.update(Integer.parseInt(fragments[0]) - 1, fragments[1]);
            storage.refile(tasklist);
            isNotice = false;
        } catch (IOException ex) {
            warn = "Cannot access storage.";
        } catch (ParsingException ex) {
            normal = ex.getMessage();
        } catch (ArrayIndexOutOfBoundsException ex) {
            normal = "Enter the edited task.";
        } catch (IndexOutOfBoundsException ex) {
            normal = "There is no such task.";
        } catch (NumberFormatException ex) {
            normal = "You can't edit your past.";
        } catch (InputMismatchException ex) {
            normal = "Give me a clue to edit stuff.";
        }
        return new Output(isNotice, normal, warn);
    }

    /**
     * Prints an message for unknown command.
     *
     * @param input User Input
     * @return Response to unknown command
     */
    private Output executeUnknown(String input) {
        String normal = String.format("I have detailed files on human anatomy, but not %s.", input);
        return new Output(true, normal);
    }
}

