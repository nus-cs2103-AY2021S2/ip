package todobeast;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

import todobeast.exceptions.InvalidInputException;
import todobeast.tasks.Deadline;
import todobeast.tasks.Event;
import todobeast.tasks.Task;
import todobeast.tasks.Todo;

/**
 * Handles CRUD functionality for storing the data produced and required by the application into a text file.
 */
public class Storage {
    public static final String STORAGE_DELIMITER = ".";
    public static final String STORAGE_DELIMITER_REGEX = "[.]";

    private final File data;

    /**
     * Creates a text file to store data in the specified directory, and stores it such that future CRUD
     * functions can be performed on it.
     * @param directoryPath the directory in which the text file is to be stored
     * @param fileName the name of the .txt file that will be created
     */
    public Storage(String directoryPath, String fileName) {
        assert directoryPath.length() > 0 : "Empty directory name given!";
        assert fileName.length() > 0 : "Empty file name given!";
        File directory = new File(directoryPath);
        boolean doesDirectoryExist = directory.exists();
        if (!doesDirectoryExist) {
            directory.mkdir();
        }
        data = new File(directoryPath + fileName);
        try {
            data.createNewFile();
        } catch (IOException e) {
            e.printStackTrace();
            System.err.println("Could not create new file, exiting process now.");
            System.exit(1);
        }
    }

    /**
     * Writes the given String data message into the text file that is stored in this Storage object.
     * @param message the message to be written
     * @throws IOException if unable to write to the file
     */
    public void saveToStorage(String message) throws IOException {

        FileWriter fileWriter = new FileWriter(data);
        fileWriter.write(message);
        fileWriter.close();
    }

    /**
     * Loads all the tasks stored in the text file and generates a List of Tasks based on that data.
     * @return a List of Tasks generated by the data present in the text file
     * @throws FileNotFoundException
     */
    public List<Task> loadTasks() throws FileNotFoundException, InvalidInputException {

        List<Task> taskList = new ArrayList<>();
        Scanner sc = new Scanner(data);

        while (sc.hasNextLine()) {
            Task newTask = null;
            String line = sc.nextLine();
            // debug
            // System.out.println(line);
            String[] taskArgs = line.split(STORAGE_DELIMITER_REGEX);

            // debug
            // System.out.println(Arrays.toString(taskArgs));
            boolean isTaskDone = taskArgs[1].equals("1");
            boolean hasTaskNotes = hasTaskNotes(taskArgs);

            switch (taskArgs[0]) {
            // format: TODO.1.desc.(optional)taskNotes
            case "TODO":
                if (hasTaskNotes) {
                    newTask = new Todo(taskArgs[2], isTaskDone, taskArgs[3]);
                } else {
                    newTask = new Todo(taskArgs[2], isTaskDone, null);
                }
                break;
            // format: DEADLINE.1.desc.date.time.(optional)taskNotes
            case "DEADLINE":
                if (hasTaskNotes) {
                    newTask = new Deadline(taskArgs[2], isTaskDone, LocalDate.parse(taskArgs[3]),
                            LocalTime.parse(taskArgs[4]), taskArgs[5]);
                } else {
                    newTask = new Deadline(taskArgs[2], isTaskDone, LocalDate.parse(taskArgs[3]),
                            LocalTime.parse(taskArgs[4]), null);
                }
                break;
            // format: EVENT.1.desc.date.time.(optional)taskNotes
            case "EVENT":
                if (hasTaskNotes) {
                    newTask = new Event(taskArgs[2], isTaskDone, LocalDate.parse(taskArgs[3]),
                            LocalTime.parse(taskArgs[4]), taskArgs[5]);
                } else {
                    newTask = new Event(taskArgs[2], isTaskDone, LocalDate.parse(taskArgs[3]),
                            LocalTime.parse(taskArgs[4]), null);
                }
                break;
            default:
                throw new InvalidInputException("Invalid task type provided!");
            }
            taskList.add(newTask);
        }
        sc.close();
        return taskList;
    }

    private boolean hasTaskNotes(String[] taskArgs) {
        boolean hasTaskNotes;
        switch (taskArgs[0]) {
        case "TODO":
            hasTaskNotes = taskArgs.length == 4;
            break;
        case "DEADLINE":
        case "EVENT":
            hasTaskNotes = taskArgs.length == 6;
            break;
        default:
            hasTaskNotes = false;
        }
        return hasTaskNotes;
    }
}
