package task;

import util.Parser;

import java.io.IOException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import static java.time.format.DateTimeFormatter.ISO_LOCAL_DATE;

/**
 * Type of Task that stores a date by which the task should be completed.
 */
public class Deadline extends Task {
    public static final String COMMAND_STRING = "deadline";
    public static final String END_DATE_STRING = "by";
    private final LocalDate endDate;

    /**
     * Constructs a Deadline with the supplied description and date.
     *
     * @param desc String description of the Deadline.
     * @param endDate LocalDate object representing the date the Deadline should
     *                be completed.
     */
    public Deadline(String desc, LocalDate endDate) {
        super(desc);
        this.endDate = endDate;
    }

    /**
     * Overloaded constructor to create a Deadline with the supplied description,
     * date and completion status.
     *
     * @param desc String description of the Deadline.
     * @param endDate LocalDate object representing the date the Deadline should
     *                be completed.
     * @param isDone True, if the Deadline should be initialised as done.
     */
    public Deadline(String desc, LocalDate endDate, boolean isDone) {
        super(desc, isDone);
        this.endDate = endDate;
    }

    /**
     * Parses the saveString generated by toSaveString() back into a Deadline
     * object.
     *
     * @param saveString String representation of a Deadline object.
     * @return Deadline object based on the supplied saveString.
     */
    public static Deadline fromSaveString(String saveString) throws IOException  {
        HashMap<String, List<String>> commandMap = Parser.parseCommandMap(saveString);

        // Attempt to parse the description
        List<String> descriptions;
        String description;
        try {
            descriptions = commandMap.get(COMMAND_STRING);
            description = String.join(" ", descriptions);
        } catch (NullPointerException e) {
            throw new IOException("Description could not be parsed from: " + saveString);
        }

        // Attempt to parse the date from the saveString
        String endDateString;
        LocalDate endDate;
        try {
            endDateString = commandMap.get(END_DATE_STRING).get(0);
            endDate = LocalDate.parse(endDateString);
        } catch (NullPointerException | IndexOutOfBoundsException | DateTimeParseException e) {
            throw new IOException("Date could not be parsed from: " + saveString);
        }

        boolean isDone = commandMap.containsKey("done");

        return new Deadline(description, endDate, isDone);
    }

    @Override
    public String toString() {
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("E, d MMM yy");
        String dateString = endDate.format(dateTimeFormatter);
        return "[D]" + super.toString() + " (by: " + dateString + ")";
    }

    @Override
    public TaskType getTaskType() {
        return TaskType.DEADLINE;
    }

    @Override
    public String getCommandString() {
        return COMMAND_STRING;
    }

    /**
     * Convert the Deadline, its state and variables to a String representation
     * that can be parsed to obtain back the same Deadline.
     *
     * @return String representation of the Deadline and its state.
     */
    @Override
    public String toSaveString() {
        HashMap<String, List<String>> commandMap = new HashMap<>();

        // Add command flag
        commandMap.put(Parser.COMMAND_FLAG, new ArrayList<>());
        commandMap.get(Parser.COMMAND_FLAG).add(getCommandString());

        // Add description
        commandMap.put(getCommandString(), new ArrayList<>());
        commandMap.get(getCommandString()).add(super.getDescription());

        // Add end date
        commandMap.put(END_DATE_STRING, new ArrayList<>());
        commandMap.get(END_DATE_STRING).add(endDate.format(ISO_LOCAL_DATE));

        // Add done flag
        if (super.isDone()) {
            commandMap.put("done", new ArrayList<>());
        }

        return Parser.commandMapToString(commandMap);
    }
}
